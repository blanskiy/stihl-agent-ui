"""
STIHL Analytics Agent - API Routes
Implements /agent, /chat/history, and /chat endpoints for the React frontend.
"""

import json
import logging
from datetime import datetime, timezone
from typing import Dict, List, Optional, AsyncGenerator

import fastapi
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse, StreamingResponse

from agent.stihl_agent import STIHLAnalyticsAgent

logger = logging.getLogger("stihl-agent")

router = fastapi.APIRouter()

# In-memory conversation storage (per session)
# In production, you'd use Redis or a database
conversations: Dict[str, List[Dict]] = {}


def get_agent(request: Request) -> STIHLAnalyticsAgent:
    """Get the agent instance from app state."""
    return request.app.state.agent


def serialize_sse_event(data: Dict) -> str:
    """Serialize data as SSE event."""
    return f"data: {json.dumps(data)}\n\n"


@router.get("/")
async def index():
    """Health check endpoint."""
    return {"status": "ok", "agent": "STIHL Analytics Agent"}


@router.get("/health")
async def health(request: Request):
    """Detailed health check."""
    try:
        agent = get_agent(request)
        skills = agent.list_skills()
        return {
            "status": "healthy",
            "agent_ready": True,
            "skills_count": len(skills),
            "skill_routing_enabled": agent.use_skill_routing
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "agent_ready": False,
            "error": str(e)
        }


@router.get("/agent")
async def get_agent_info(request: Request):
    """Get agent details for the frontend."""
    try:
        agent = get_agent(request)
        skills = agent.list_skills()
        
        return JSONResponse(content={
            "name": "STIHL Analytics Agent",
            "metadata": {
                "logo": "chart",  # Icon name for frontend
                "description": "AI-powered analytics for STIHL equipment data",
                "skills": [s["name"] for s in skills]
            },
            "agentPlaygroundUrl": ""  # Not using managed agents
        })
    except Exception as e:
        logger.error(f"Error getting agent info: {e}")
        return JSONResponse(content={
            "name": "STIHL Analytics Agent",
            "metadata": {"logo": "chart"},
            "agentPlaygroundUrl": ""
        })


@router.get("/skills")
async def list_skills(request: Request):
    """List all available skills."""
    agent = get_agent(request)
    return JSONResponse(content=agent.list_skills())


@router.get("/chat/history")
async def get_chat_history(request: Request):
    """Get chat history for the current session."""
    # Get conversation ID from cookie
    conversation_id = request.cookies.get("conversation_id", "default")
    
    history = conversations.get(conversation_id, [])
    
    # Format for frontend
    formatted_history = []
    for msg in history:
        formatted_history.append({
            "role": msg["role"],
            "content": msg["content"],
            "created_at": msg.get("created_at", ""),
            "annotations": msg.get("annotations", [])
        })
    
    response = JSONResponse(content=formatted_history)
    response.set_cookie("conversation_id", conversation_id)
    return response


@router.post("/chat")
async def chat(request: Request):
    """
    Handle chat messages with SSE streaming.
    """
    # Get conversation ID from cookie or create new
    conversation_id = request.cookies.get("conversation_id")
    if not conversation_id:
        conversation_id = f"conv_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    # Parse request
    try:
        body = await request.json()
        user_message = body.get("message", "")
    except Exception as e:
        logger.error(f"Invalid request body: {e}")
        raise HTTPException(status_code=400, detail="Invalid JSON in request")
    
    if not user_message:
        raise HTTPException(status_code=400, detail="Message is required")
    
    # Get agent
    agent = get_agent(request)
    
    # Initialize conversation if needed
    if conversation_id not in conversations:
        conversations[conversation_id] = []
    
    # Store user message
    user_timestamp = datetime.now(timezone.utc).timestamp()
    conversations[conversation_id].append({
        "role": "user",
        "content": user_message,
        "created_at": str(user_timestamp)
    })
    
    async def generate_response() -> AsyncGenerator[str, None]:
        """Generate SSE events for the response."""
        try:
            # Log routing info
            if agent.use_skill_routing:
                routing = agent.get_routing_explanation(user_message)
                logger.info(f"Routing: {routing}")
            
            # Get response from agent
            response = agent.chat(user_message)
            
            # Stream the response in chunks for better UX
            # (Your agent returns full response, so we simulate streaming)
            chunk_size = 50
            full_response = response
            
            # Send chunks
            for i in range(0, len(full_response), chunk_size):
                chunk = full_response[i:i + chunk_size]
                yield serialize_sse_event({
                    "type": "message",
                    "content": chunk
                })
            
            # Send completed message
            yield serialize_sse_event({
                "type": "completed_message",
                "content": full_response,
                "annotations": []  # Add annotations if you have them
            })
            
            # Store assistant message
            assistant_timestamp = datetime.now(timezone.utc).timestamp()
            conversations[conversation_id].append({
                "role": "assistant",
                "content": full_response,
                "created_at": str(assistant_timestamp),
                "annotations": []
            })
            
        except Exception as e:
            logger.error(f"Error generating response: {e}")
            yield serialize_sse_event({
                "type": "completed_message",
                "content": f"I encountered an error: {str(e)}",
                "annotations": []
            })
        
        finally:
            # Always send stream end
            yield serialize_sse_event({"type": "stream_end"})
    
    # Create streaming response
    response = StreamingResponse(
        generate_response(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        }
    )
    
    # Set cookie
    response.set_cookie("conversation_id", conversation_id)
    
    return response


@router.post("/chat/reset")
async def reset_chat(request: Request):
    """Reset the conversation."""
    conversation_id = request.cookies.get("conversation_id", "default")
    
    # Clear conversation history
    if conversation_id in conversations:
        del conversations[conversation_id]
    
    # Reset agent conversation
    agent = get_agent(request)
    agent.reset_conversation()
    
    return JSONResponse(content={"status": "reset", "conversation_id": conversation_id})


@router.get("/route")
async def explain_routing(request: Request, query: str):
    """Explain how a query would be routed (for debugging)."""
    agent = get_agent(request)
    explanation = agent.get_routing_explanation(query)
    return JSONResponse(content={"query": query, "routing": explanation})